# 객체지향 프로그래밍.
## 파이썬은 모든 것이 **객체**
```
#절차지향
a = [1,2,3]
a = sorted(a)
a = reverserd(a)
#...

#객체지향

a = [1,2,3]
a.sort()
a.reverse()
#. . . .

```

* 객체 지향 프로그래밍이 필요한 이유!<br>
    * 현실 세계를 프로그램 설계에 반영<br>

ex)<br>
* 사각형 - 클래스
* r1,r2(각 사각형) - 인스턴스
* 사각형의 정보 - 속성
    * 가로 길이, 세로길이
* 사각형의 행동 - 메소드
    * 넓이를 구한다. 높이를 구한다\

* 객체지향의 장점
    1. 프로그램을 유연하고 변경이 용이하게 만들기 떄문에 대규모 소프트웨어 개발에 많이 사용됨.
    2. 또한, 프로그래밍을 더 배우기 쉽게하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는 장점을 가지고 있습니다.

## OOP 기초
### 기본문법
* 클래스 정의 class MyClass:(class + 이름)
* 인스턴스 생성 my_instance = MyClass() (변수 = class)
* 메소드 호출 my_istance.my_method()
* 속성 my_instance.my_attribute
(ex.<br>
result = list()<br>
result.append()<br>
....)

### 클래스와 인스턴스
* 클래스 : 객체들의 분류
* 인스턴스 : 하나하나의 실체/예
* 메소드 : 특정 데이터 타입/클래스 의 객체에 공통적으로 적용 가능한 행위(함수)

### 객체 비교하기
* ==
    * 동등한
    * 변수가 참조하는 객체가 동등한(내용이 같은) 경우 True
    * 두 객체가 같아 보이지만 실제로 동일한 대상을 가리키고 있다고 확인해 준 것은 아님
* is
    * 동일한(identical)
    * 두 변수가 동일한 객체를 가리키는 경우 True

### 인스턴스 변수
* 인스턴스 변수란?
    * 인스턴스가 개인적으로 가지고 있는 속성
    * 각 인스턴스의 고유한 변수
* 생성자 메소드에서 self.name 으로 정의
* 인스턴스가 생성된 이후 instance.name 으로 선언

### 인스턴스 메소드
* 인스턴스 변수를 사용하거나, 인스턴스 변수에 값을 설정하는 메소드
* 클래스 내부에 정의되는 메소드의 기본
* 호출 시, 첫번째 인자로 인스턴스 자기자신(self)이 전달됨<br>
instance_method(self, arg1,....) 

### self
* 인스턴스 자기자신
* 파이썬에서 인스턴스 메소드는 자기자신을 먼저 불러오게 설계됨

### 생성자 메소드
* 인스턴스 객체가 생성될 때 자동으로 호출되는 메소드(__ init __)
```
class Person:

    def __init__(self):
        print('응애!')

class Person:

    def __init__(self, name, age):
    # 인스턴스 변수를 받아서 정의하기 위해 사용!
        self.name = name
        self.age = age
```
* 인스턴스 변수들의 초기값을 설정
    * 인스턴스 생성
### 소멸자 메소드
* 소멸 직전에 호출되는 메소드 (__ del __)

### 매직 매소드
* 특수한 동작을 위해 만들어진 메소드
* 특정 상황에 자동으로 불리는 메소드

### 클래스 변수
* 클래스 변수
    * 한 클래스의 모든 인스턴스라도 똑같은 값을 가지고 있는 속성
* 클래스 이름 대신 인스턴스 이름을 쓰면?
    * 인스턴스 변수

### 클래스 메소드
* 클래스가 사용할 메소드
* @classmethod 데코레이터를 사용해 정의합니다.
* 매서드 호출시 첫번째 인자로 클래스 cls가 전달됩니다.

### 스태틱 메소드
* 클래스가 사용할 메소드
* 인스턴스와 클래스의 속성과 무관한 메서드
* @staticmethod 데코레이터를 사용하여 정의
* 호출시 어떤한 인자도 전달되지않습니다.
* 속성을 다루지 않고 단지 기능만을 하는 매서드 정의

## 객체 지향의 핵심개녕 4가지
* 추상화 : 현실 세계를 프로그램 설계에 반영
* 상속 : 두 클래스 사이에 부모-자식 관계를 정립하는 것
* 다형성
* 캡슐화

### 추상화
* 현실 세계를 프로그램 설계에 반영

### 상속
* 하위 클래스는 상위 클래스에 정의된 속성, 행동, 관계 및 제약 조건을 모두 상속받음.
* 부모 클래스의 속성,메소드가 자식 클래스에 상속되므로, 코드 재활용성이 높아짐

### 다중상속
* 두개 이상의 클래스를 상속받는 경우. 부모 클래스의 모든 
* mro 메소드 : 해당 인스턴스의 클래스가 어떤 부모 클래스를 가지는지 확인하는 메소드.

## 메소드 오버라이딩
* 상속 받은 메소드를 재정의
    * 상속받은 클래스에서 같은 이름의 메소드로 덮어씀
    * 부모 클래스의 메소드를 실행 시키고 싶은 경우 super를 활용

## 캡슐화
* 객체의 일부 구현 내용을
* 


## 알고리즘
```
# 만들 리스트 준비
alpha_list= [[],[],[]]
# 알파벳 입력받음(대문자)
alpha = ord(input("알파벳(대문자)를 입력해 주세요 : "))
n = 0
# 3번 반복을 위해 N을 0에서 2까지 증가
while n < 3:
    # N+1 번 만큼 alpha_list에 받은 알파벳을 1씩 더하면서 추가
    for i in range(n+1):
        alpha_list[2-n].append(chr(alpha))
        # 알파벳이 Z를 넘어가면 다시 A부터 시작
        alpha = (alpha+1-ord('A'))% 26 + ord('A')
    n += 1

for i in alpha_list:
    print(i)
```
